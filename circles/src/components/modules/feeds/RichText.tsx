"use client";

import { ContentPreviewData, MentionDisplay } from "@/models/models";
import ReactMarkdown from "react-markdown";
import remarkGfm from "remark-gfm"; // Handles GitHub Flavored Markdown, including autolinking
import React, { memo, useMemo, useCallback, ComponentProps } from "react"; // Import React and ComponentProps
import { useIsMobile } from "@/components/utils/use-is-mobile";
import { useRouter } from "next/navigation";
import Link from "next/link"; // Import Next Link
import { useAtom } from "jotai";
import { contentPreviewAtom, sidePanelContentVisibleAtom } from "@/lib/data/atoms";

// MentionHoverCard remains the same
type MentionHoverCardProps = {
    mention: MentionDisplay;
    children: React.ReactNode;
};

const MentionHoverCard = memo(({ mention, children }: MentionHoverCardProps) => {
    const [, setContentPreview] = useAtom(contentPreviewAtom);
    const [sidePanelContentVisible] = useAtom(sidePanelContentVisibleAtom);
    const isMobile = useIsMobile();
    const router = useRouter();

    const openMention = useCallback(() => {
        if (!mention.circle) return; // Guard against missing circle data

        if (isMobile) {
            if (mention.circle.handle) {
                router.push(`/circles/${mention.circle.handle}`);
            }
            return;
        }

        let contentPreviewData: ContentPreviewData = {
            type: "circle",
            content: mention.circle,
        };
        setContentPreview((x) =>
            x?.content?._id === mention.circle?._id && sidePanelContentVisible === "content"
                ? undefined
                : contentPreviewData,
        );
    }, [mention.circle, setContentPreview, sidePanelContentVisible, isMobile, router]);

    return (
        <span className="cursor-pointer font-semibold text-blue-600 hover:underline" onClick={openMention}>
            {children}
        </span>
    );
});
MentionHoverCard.displayName = "MentionHoverCard";

type RichTextProps = {
    content: string;
    mentions?: MentionDisplay[];
};

const RichText = memo(({ content, mentions }: RichTextProps) => {
    // remarkGfm handles autolinking, so we don't need needsMarkdown check anymore for basic links
    const hasMentions = mentions && mentions.length > 0;

    const components = useMemo(() => {
        return {
            // Customize anchor tags
            // Use a more specific type or 'any' if necessary for react-markdown props
            a: ({
                node,
                href,
                children,
                ...props
            }: {
                node?: any;
                href?: string;
                children?: React.ReactNode;
                [key: string]: any;
            }) => {
                if (!href) {
                    // Render children as text if href is missing
                    return <>{children}</>;
                }

                // Check if it's a mention link generated by MentionsInput
                const mentionMatch = href.match(/^\/circles\/(.+)/);
                if (mentionMatch && hasMentions) {
                    const mentionIdOrHandle = mentionMatch[1];
                    // Match by ID first, then handle as fallback if needed
                    const mention = mentions!.find(
                        (m) => m.id === mentionIdOrHandle || m.circle?.handle === mentionIdOrHandle,
                    );
                    if (mention?.circle) {
                        // Ensure circle data exists
                        return <MentionHoverCard mention={mention}>{children}</MentionHoverCard>;
                    } else {
                        // If mention data is incomplete, render as plain text or a basic link
                        console.warn("Incomplete mention data for:", href);
                        return <span className="font-semibold">{children}</span>; // Or render as a basic link: <a href={href} {...props}>{children}</a>
                    }
                }

                // Check if it's an external link
                if (href.startsWith("http://") || href.startsWith("https://")) {
                    return (
                        <a
                            href={href}
                            target="_blank"
                            rel="noopener noreferrer"
                            className="text-blue-600 hover:underline"
                            {...props}
                        >
                            {children}
                        </a>
                    );
                }

                // Handle other internal links (if any) using Next Link
                // Avoid passing potentially invalid props like 'node' to Next Link
                const { node: _, ...linkProps } = props;
                return (
                    <Link href={href} {...linkProps} className="text-blue-600 hover:underline">
                        {children}
                    </Link>
                );
            },
            // Ensure paragraphs and other block elements allow word breaks
            // Destructure node separately
            // Use break-words (overflow-wrap)
            p: ({ node, ...props }: { node?: any; [key: string]: any }) => <p className="break-words" {...props} />,
            li: ({ node, ...props }: { node?: any; [key: string]: any }) => <li className="break-words" {...props} />,
            // Add other block elements as needed (e.g., blockquote, pre)
            blockquote: ({ node, ...props }: { node?: any; [key: string]: any }) => (
                <blockquote className="break-words" {...props} />
            ),
            // Add styling for preformatted text (code blocks)
            pre: ({ node, ...props }: { node?: any; [key: string]: any }) => (
                <pre className="overflow-x-auto rounded bg-gray-100 p-2" {...props} />
            ),
        };
    }, [mentions, hasMentions]); // Include hasMentions

    // Keep min-w-0 on the root, break-words is handled by parent or specific elements
    return (
        <div className="min-w-0">
            <ReactMarkdown remarkPlugins={[remarkGfm]} components={components}>
                {content}
            </ReactMarkdown>
        </div>
    );
});

RichText.displayName = "RichText";

export default RichText;
